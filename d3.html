<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <script
      src="https://www.unpkg.com/d3@7.0.1/dist/d3.min.js"
      type="text/javascript"
    ></script>
    <!-- <script src="https://d3js.org/d3.v6.js" type="text/javascript"></script> -->
    <style type="text/css">
      .category:hover {
        fill: black;
      }

      .category {
        clip-path: url(#clip);
      }
    </style>
    <title>The Media Coverage of 5 Topics from 2007 to 2021</title>
  </head>
  <body>
    <header>
      <h1>The Media Coverage of 5 Topics from 2007 to 2021</h1>
      <p>
        This website visualises the Media Coverage of 5 Topics from 2007 to
        2021.
      </p>
      <p>Data Source: XXX Institution<a href="http://"></a></p>
    </header>
    <div class="canvas"></div>
    <footer>
      <table style="border: 1px solid">
        <tr>
          <td style="border: 1px solid">Proportion</td>
          <td style="border: 1px solid">Trend</td>
          <td style="border: 1px solid">Data</td>
          <td style="border: 1px solid">Download</td>
          <td style="border: 1px solid">SourceCode</td>
          <td style="border: 1px solid">Full Screen</td>
        </tr>
      </table>
    </footer>
    <div id="tooltip" class="tooltip">
      <div class="tooltipDate">
        <span id="date"></span>
      </div>
      <div class="tooltipDetail">
        Detail Information: <span id="tooltipDetail"></span>
      </div>
    </div>
    <script>
      const focusMargin = { top: 20, right: 20, bottom: 100, left: 40 };
      const contextMargin = { top: 400, right: 20, bottom: 20, left: 40 };
      const width = 960 - focusMargin.left - focusMargin.right;
      const focusHeight = 480 - focusMargin.top - focusMargin.bottom;
      const contextHeight = 480 - contextMargin.top - contextMargin.bottom;

      const parseTime = d3.timeParse("%Y-%m-%d");

      const xScale = d3.scaleTime().range([0, width]);
      const yScale = d3.scaleLinear().range([focusHeight, 0]);
      const xScaleContext = d3.scaleTime().range([0, width]);

      const xAxis = d3.axisBottom(xScale);
      const yAxis = d3.axisLeft(yScale);
      const xAxisContext = d3.axisBottom(xScaleContext);

      const svg = d3
        .select(".canvas")
        .append("svg")
        // .attr("viewBox", [0, 0, 960, 480])
        .attr("width", "960")
        .attr("height", "480");

      const brush = d3
        .brushX()
        .extent([
          [0, 0],
          [width, contextHeight],
        ])
        .on("brush", brushed);
      // .on("end", brushended);

      // const zoom = d3
      //   .zoom()
      //   .scaleExtent([1, Infinity])
      //   .translateExtent([
      //     [0, 0],
      //     [width, focusHeight],
      //   ])
      //   .extent([
      //     [0, 0],
      //     [width, focusHeight],
      //   ])
      //   .on("zoom", zoomed);

      const focusArea = (x, y) =>
        d3
          .area()
          .curve(d3.curveMonotoneX)
          .x((d) => {
            // console.log(d.data.date);
            return x(d.data.date);
          })
          .y0((d) => y(d[0]))
          .y1((d) => y(d[1]));

      const contextArea = (x, y) =>
        d3
          .area()
          .x((d) => x(d.data.date))
          .y0(y(0))
          .y1((d) => y(d[1]));

      svg
        .append("defs")
        .append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("width", width)
        .attr("height", focusHeight);

      const focusSVG = svg
        .append("g")
        .attr("class", "focus")
        .attr(
          "transform",
          `translate(${focusMargin.left}, ${focusMargin.top})`
        );

      const contextSVG = svg
        .append("g")
        .attr("class", "context")
        .attr(
          "transform",
          `translate(${contextMargin.left}, ${contextMargin.top})`
        );

      d3.json("./data.json").then((rawData) => {
        /**
         * Restructure Raw Data, Parse Date
         */
        let data = [];
        // There is another way to build data
        // const data = Object.keys(rawData).map(key => ({date: key, values: rawData[key]}));
        //build date parser

        for (const day in rawData) {
          //remove outliers
          // if (
          //   rawData[day]["education"] > 198 ||
          //   rawData[day]["crime"] > 32 ||
          //   rawData[day]["homeless"] > 12 ||
          //   rawData[day]["poverty"] > 13 ||
          //   rawData[day]["unemploy"] > 44
          // )
          //   continue;
          // if (rawData[day]["education"] <= 10) console.log(day);
          rawData[day].date = parseTime(day);
          data.push(rawData[day]);
        }

        //Sort Data by Dates
        data = data.sort((a, b) => d3.ascending(a.date, b.date));

        //Figure Out Keys
        const keys = Object.keys(rawData[Object.keys(rawData)[0]]).slice(0, 5);
        // console.log(keys);
        // const keys = Object.keys(rawData[Object.keys(rawData)[0]]).slice(0, 4);

        // //!!!!!!!!!!!!!!!!!!!!!Slice the data a little!!!!!!!!!!!!!!!!!!!!!!!!
        // data = data.splice(0, 50);
        // console.log(data);

        //Stack Data
        const series = d3.stack().keys(keys)(
          // .order(d3.stackOrderInsideOut)
          // .offset(d3.stackOffsetWiggle)
          data
        );
        // console.log(series);

        //color
        const color = d3.scaleOrdinal().domain(keys).range(d3.schemeCategory10);

        //domain management
        xScale.domain(d3.extent(data, (d) => d.date));
        yScale.domain(
          d3.extent(data, (d) =>
            d3.sum(Object.values(d).filter((value) => value <= 100000))
          )
        );
        xScaleContext.domain(d3.extent(data, (d) => d.date));

        /**
         * Render the SVG
         */

        focusSVG
          .selectAll("path")
          .data(series)
          .join("path")
          .attr("fill", ({ key }) => color(key))
          .attr("d", focusArea(xScale, yScale))
          .attr("class", "category")
          .append("title")
          .text((d) => d.key);

        focusSVG
          .append("g")
          .attr("class", "axis axis--x")
          .attr("transform", `translate(0,${focusHeight})`)
          .call(xAxis);

        focusSVG.append("g").attr("class", "axis axis--y").call(yAxis);

        contextSVG
          .append("path")
          .datum(series[4])
          .attr("fill", "steelblue")
          .attr(
            "d",
            contextArea(xScale, yScale.copy().range([contextHeight, 0]))
          );

        contextSVG
          .append("g")
          .attr("class", "axis axis--x2")
          .attr("transform", `translate(0,${contextHeight})`)
          .call(xAxisContext);

        contextSVG
          .append("g")
          .attr("class", "brush")
          .call(brush)
          .call(brush.move, xScale.range());
      });

      function brushed({ selection }) {
        if (selection) {
          xScale.domain(selection.map(xScaleContext.invert, xScaleContext));
          focusSVG.selectAll(".category").attr("d", focusArea(xScale, yScale));
          focusSVG.select(".axis--x").call(xAxis);
          // svg
          //   .select(".zoom")
          //   .call(
          //     zoom.transform,
          //     d3.zoomIdentity.scale(width / (s[1] - s[0])).translate(-s[0], 0)
          //   );
        }
      }

      // const defaultSelection = [
      //   xScale(d3.timeYear.offset(xScale.domain()[1], -1)),
      //   xScale.range()[1],
      // ];

      // const gbrush = svg
      //   .append("g")
      //   .attr("transform", `translate(0, ${height - plotMargin.bottom + 20})`)
      //   .call(brush)
      //   .call(brush.move, defaultSelection);

      // //have a look here...
      // function brushed({ selection }) {
      //   if (selection) {
      //     const [minX, maxX] = selection.map(xScale.invert); //here
      //     // const maxY = contextHeight;//here
      //     // yScale.copy().domain(0, maxY); //and here
      //     d3.selectAll(".category").attr(
      //       "d",
      //       areaFocus(xScale.copy().domain([minX, maxX]), yScale)
      //     );
      //     // d3.select(".xAxis").call(xAxis(xScale.copy().domain([minX, maxX])));
      //   }
      // }

      // function brushended({ selection }) {
      //   if (!selection) {
      //     gbrush.call(brush.move, defaultSelection);
      //   }
      // }

      // svg
      //   .append("rect")
      //   .attr("class", "zoom")
      //   .attr("width", width)
      //   .attr("height", height)
      //   .attr(
      //     "transform",
      //     "translate(" + margin.left + "," + margin.top + ")"
      //   )
      //   .call(zoom);

      // //Create Time Scaled X Axis, then Render
      // const xScale = d3
      //   .scaleTime()
      //   .domain(d3.extent(data, (d) => d.date)) //getting the max and min dates
      //   .range([0, width - plotMargin.left - plotMargin.right]);
      // //have a look here
      // const xAxis = (x) =>
      //   svg
      //     .append("g")
      //     .attr("class", "xAxis")
      //     .attr(
      //       "transform",
      //       `translate(${plotMargin.left},${height - plotMargin.bottom})`
      //     )
      //     .call(
      //       d3
      //         .axisBottom(x)
      //         .ticks(width / 80)
      //         .tickSizeOuter(0)
      //     )
      //     .call((g) => g.select(".domain").remove());

      // xAxis(xScale);

      // //Create Linear Scales Y Axis, then Render
      // const yScale = d3
      //   .scaleLinear()
      //   .domain(
      //     d3.extent(data, (d) =>
      //       d3.sum(Object.values(d).filter((value) => value <= 100000))
      //     )
      //   )
      //   .range([height, plotMargin.bottom]);

      // const yAxis = d3.axisLeft(yScale);
      // svg
      //   .append("g")
      //   .attr(
      //     "transform",
      //     `translate(${plotMargin.left},${-plotMargin.bottom})`
      //   )
      //   .call(yAxis);

      // //Color Palette

      // //Create PlotFocus Area
      // const focus = svg
      //   .append("g")
      //   .attr("class", "focus")
      //   .attr(
      //     "transform",
      //     `translate(${plotMargin.left}, ${-plotMargin.bottom})`
      //   )
      //   .selectAll("path")
      //   .data(series)
      //   .join("path")
      //   .attr("fill", ({ key }) => color(key))
      //   .attr("d", areaFocus(xScale, yScale))
      //   .attr("class", "category")
      //   .append("title")
      //   .text((d) => d.key);

      // const context = svg
      //   .append("g")
      //   .attr("class", "context")
      //   .attr(
      //     "transform",
      //     `translate(${plotMargin.left}, ${height - plotMargin.bottom + 20})`
      //   )
      //   .append("path")
      //   .datum(series[4])
      //   .attr("fill", "steelblue")
      //   .attr(
      //     "d",
      //     areaContext(xScale, yScale.copy().range([contextHeight, 0]))
      //   );

      // //Render Areas

      // //Focus and Context
      // // const brush = d3
      // //   .brushX()
      // //   .extent([
      // //     [plotMargin.left, 0],
      // //     [width - plotMargin.left, contextHeight],
      // //   ])
      // //   .on("brush", brushed)
      // //   .on("end", brushended);

      // const defaultSelection = [
      //   xScale(d3.timeYear.offset(xScale.domain()[1], -1)),
      //   xScale.range()[1],
      // ];

      // const gbrush = svg
      //   .append("g")
      //   .attr("transform", `translate(0, ${height - plotMargin.bottom + 20})`)
      //   .call(brush)
      //   .call(brush.move, defaultSelection);

      // //have a look here...
      // function brushed({ selection }) {
      //   if (selection) {
      //     const [minX, maxX] = selection.map(xScale.invert); //here
      //     // const maxY = contextHeight;//here
      //     // yScale.copy().domain(0, maxY); //and here
      //     d3.selectAll(".category").attr(
      //       "d",
      //       areaFocus(xScale.copy().domain([minX, maxX]), yScale)
      //     );
      //     // d3.select(".xAxis").call(xAxis(xScale.copy().domain([minX, maxX])));
      //   }
      // }

      // function brushended({ selection }) {
      //   if (!selection) {
      //     gbrush.call(brush.move, defaultSelection);
      //   }
      // }

      //Zooming and Paning
      // const zoom = d3.zoom().on("zoom", (e) => {
      //   svg.select(".category").attr("transform", (transform = e.transform));
      // });
      // svg.call(zoom);

      //Tooltip
      // var tooltip = d3
      //   .select("body")
      //   .append("div")
      //   .attr("class", "remove")
      //   .style("position", "absolute")
      //   .style("z-index", "20")
      //   .style("visibility", "hidden")
      //   .style("top", "30px")
      //   .style("left", "55px");

      // Date Selector
      // const listeningRect = plotG //this rect captures the mouse movements
      //   .append("rect")
      //   .attr("class", "listeningRect")
      //   .attr("width", width)
      //   .attr("height", height)
      //   .attr("fill", "transparent")
      //   .on("mousemove", (event) => {
      //     const mousePosition = d3.pointer(event);
      //     const hoveredDate = xScale.invert(mousePosition[0]);
      //     const getDistanceFromHoveredDate = (d) =>
      //       Math.abs(xAccessor(d) - hoveredDate);
      //     const closestIndex = d3.scan(
      //       series,
      //       (a, b) =>
      //         getDistanceFromHoveredDate(a) - getDistanceFromHoveredDate(b)
      //     );
      //   });
      // // .on("mouseleave", onMouseLeave);

      // //it's not working???...
      // const xLine = plotG
      //   .append("rect")
      //   .attr("class", "dotted")
      //   .attr("stroke-width", "1px")
      //   .attr("width", ".5px")
      //   .attr("height", height);
      // });
    </script>
  </body>
</html>
