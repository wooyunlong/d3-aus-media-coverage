<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <script
      src="https://www.unpkg.com/d3@7.0.1/dist/d3.min.js"
      type="text/javascript"
    ></script>
    <!-- <script src="https://d3js.org/d3.v6.js" type="text/javascript"></script> -->
    <style type="text/css">
      header {
        box-shadow: 2px 2px 24px -4px rgba(0, 0, 0, 0.59);
      }

      footer {
        box-shadow: 2px 2px 24px -4px rgba(0, 0, 0, 0.59);
        margin-top: 10px;
      }

      .category {
        clip-path: url(#clip);
      }

      .category:hover {
        fill: black;
      }

      .canvas {
        box-shadow: 2px 2px 24px -4px rgba(0, 0, 0, 0.59);
      }

      #tooltip {
        visibility: hidden;
        position: absolute;
        text-align: left;
        width: 120px;
        height: 210px;
        padding: 10px;
        font: 17px sans-serif;
        background: white;
        box-shadow: 2px 2px 24px -4px rgba(0, 0, 0, 0.59);
        pointer-events: none;
      }

      /* .zoom {
        cursor: move;
        fill: none;
        pointer-events: all;
      } */
    </style>
    <title>The Media Coverage of 5 Topics from 2007 to 2021</title>
  </head>
  <body>
    <header>
      <h1>The Media Coverage of 5 Topics from 2007 to 2021</h1>
      <p>
        This website visualises the Media Coverage of 5 Topics from 2007 to
        2021.
      </p>
      <p>Data Source: XXX Institution<a href="http://"></a></p>
    </header>
    <div class="canvas"></div>
    <footer>
      <table style="border: 1px solid">
        <tr style="border: 1px solid">
          <td style="border: 1px solid">Proportion</td>
          <td style="border: 1px solid">Trend</td>
          <td style="border: 1px solid">Data</td>
          <td style="border: 1px solid">Download</td>
          <td style="border: 1px solid">SourceCode</td>
          <td style="border: 1px solid">Full Screen</td>
        </tr>
      </table>
    </footer>
    <div id="tooltip">
      <div id="tooltipDate"></div>
      <div id="tooltipDetail"></div>
    </div>
    <script>
      const focusMargin = { top: 20, right: 20, bottom: 100, left: 40 };
      const contextMargin = { top: 400, right: 20, bottom: 20, left: 40 };
      const width = 960 - focusMargin.left - focusMargin.right;
      const focusHeight = 480 - focusMargin.top - focusMargin.bottom;
      const contextHeight = 480 - contextMargin.top - contextMargin.bottom;

      const parseTime = d3.timeParse("%Y-%m-%d");
      const formatTime = d3.timeFormat("%Y-%m-%d");

      const xScale = d3.scaleTime().range([0, width]);
      const yScale = d3.scaleLinear().range([focusHeight, 0]);
      const xScaleContext = d3.scaleTime().range([0, width]);

      const xAxis = d3
        .axisBottom(xScale)
        .ticks(width / 80)
        .tickSizeOuter(0);
      const yAxis = d3.axisLeft(yScale);
      const xAxisContext = d3.axisBottom(xScaleContext);

      const svg = d3
        .select(".canvas")
        .append("svg")
        .attr("viewBox", [0, 0, 960, 480]);
      // .attr("width", "960")
      // .attr("height", "480");

      const brush = d3
        .brushX()
        .extent([
          [0, 0],
          [width, contextHeight],
        ])
        .on("brush", brushed);

      // const zoom = d3
      //   .zoom()
      //   .scaleExtent([1, Infinity])
      //   .translateExtent([
      //     [0, 0],
      //     [width, focusHeight],
      //   ])
      //   .extent([
      //     [0, 0],
      //     [width, focusHeight],
      //   ])
      //   .on("zoom", zoomed);

      const focusArea = (x, y) =>
        d3
          .area()
          .curve(d3.curveMonotoneX)
          .x((d) => {
            // console.log(d.data.date);
            return x(d.data.date);
          })
          .y0((d) => y(d[0]))
          .y1((d) => y(d[1]));

      const contextArea = (x, y) =>
        d3
          .area()
          .x((d) => x(d.data.date))
          .y0(y(0))
          .y1((d) => y(d[1]));

      const clip = svg
        .append("defs")
        .append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("width", width)
        .attr("height", focusHeight);

      const focusSVG = svg
        .append("g")
        .attr("class", "focus")
        .attr(
          "transform",
          `translate(${focusMargin.left}, ${focusMargin.top})`
        );

      const contextSVG = svg
        .append("g")
        .attr("class", "context")
        .attr(
          "transform",
          `translate(${contextMargin.left}, ${contextMargin.top})`
        );

      d3.json("./data.json").then((rawData) => {
        /**
         * Restructure Raw Data, Parse Date
         */
        let data = [];
        // There is another way to build data
        // const data = Object.keys(rawData).map(key => ({date: key, values: rawData[key]}));
        //build date parser

        for (const day in rawData) {
          //remove outliers
          // if (
          //   rawData[day]["education"] > 198 ||
          //   rawData[day]["crime"] > 32 ||
          //   rawData[day]["homeless"] > 12 ||
          //   rawData[day]["poverty"] > 13 ||
          //   rawData[day]["unemploy"] > 44
          // )
          //   continue;
          // if (rawData[day]["education"] <= 10) console.log(day);
          rawData[day].date = parseTime(day);
          data.push(rawData[day]);
        }

        //Sort Data by Dates
        data = data.sort((a, b) => d3.ascending(a.date, b.date));

        //Figure Out Keys
        const keys = Object.keys(rawData[Object.keys(rawData)[0]]).slice(0, 5);
        console.log(keys);
        // const keys = Object.keys(rawData[Object.keys(rawData)[0]]).slice(0, 4);

        // //!!!!!!!!!!!!!!!!!!!!!Slice the data a little!!!!!!!!!!!!!!!!!!!!!!!!
        // data = data.splice(0, 2);
        // console.log(data);

        //Stack Data
        const series = d3
          .stack()
          .keys(keys)
          .order(d3.stackOrderInsideOut)
          .offset(d3.stackOffsetSilhouette)(data);
        console.log(series);

        //color
        const color = d3.scaleOrdinal().domain(keys).range(d3.schemeSet1);

        //domain management
        xScale.domain(d3.extent(data, (d) => d.date));
        yScale.domain([
          d3.min(series, (d) => d3.min(d, (d) => d[0])),
          d3.max(series, (d) => d3.max(d, (d) => d[1])),
        ]);
        xScaleContext.domain(d3.extent(data, (d) => d.date));

        /**
         * Render the SVG
         */

        focusSVG
          .selectAll("path")
          .data(series)
          .join("path")
          .attr("fill", ({ key }) => color(key))
          .attr("d", focusArea(xScale, yScale))
          .attr("class", "category")
          .append("title")
          .text((d) => d.key);

        focusSVG
          .append("g")
          .attr("class", "axis axis--x")
          .attr("transform", `translate(0,${focusHeight})`)
          .call(xAxis);

        focusSVG.append("g").attr("class", "axis axis--y").call(yAxis);

        contextSVG
          .append("path")
          .datum(series[4])
          .attr("fill", "black")
          .attr(
            "d",
            contextArea(xScale, yScale.copy().range([contextHeight, 0]))
          );

        contextSVG
          .append("g")
          .attr("class", "axis axis--x2")
          .attr("transform", `translate(0,${contextHeight})`)
          .call(xAxisContext);

        contextSVG
          .append("g")
          .attr("class", "brush")
          .call(brush)
          .call(brush.move, xScale.range());

        // Date Selector
        focusSVG
          .append("rect")
          .attr("class", "listeningRect")
          .attr("width", width)
          .attr("height", focusHeight)
          .attr("fill", "transparent")
          .on("mousemove", (event) => {
            const mousePosition = d3.pointer(event);
            const hoveredDate = formatTime(xScale.invert(mousePosition[0]));
            dataSelector.attr("fill", "black").attr("x", mousePosition[0]);

            if (rawData[hoveredDate]) {
              const arr = [];
              for (let key in rawData[hoveredDate]) {
                if (key !== "date")
                  arr.push(
                    "<p>" + key + ": " + rawData[hoveredDate][key] + "</p>"
                  );
              }

              d3.select("#tooltip")
                .style("position", "absolute")
                .style("left", mousePosition[0] + 70 + "px")
                .style("top", mousePosition[1] + 110 + "px")
                .style("visibility", "visible");

              d3.select("#tooltipDate").text(hoveredDate);

              d3.select("#tooltipDetail").html(`${arr.join("")}`);
            }
          });

        const dataSelector = focusSVG
          .append("rect")
          .attr("class", "dotted")
          .attr("stroke-width", "1px")
          .attr("width", "3px")
          .attr("height", focusHeight)
          .attr("fill", "none");
        // .on("mouseleave", onMouseLeave);

        // svg
        //   .append("rect")
        //   .attr("class", "zoom")
        //   .attr("width", width)
        //   .attr("height", focusHeight)
        //   .attr(
        //     "transform",
        //     `translate(${focusMargin.left} , ${focusMargin.top})`
        //   )
        //   .call(zoom);
      });

      function brushed({ sourceEvent, selection, type }) {
        if (sourceEvent && type === "zoom") return;
        xScale.domain(selection.map(xScaleContext.invert, xScaleContext));
        focusSVG.selectAll(".category").attr("d", focusArea(xScale, yScale));
        focusSVG.select(".axis--x").call(xAxis);
        // svg
        //   .select(".zoom")
        //   .call(
        //     zoom.transform,
        //     d3.zoomIdentity
        //       .scale(width / (selection[1] - selection[0]))
        //       .translate(-selection[0], 0)
        //   );
      }

      // function zoomed({ sourceEvent, transform, type }) {
      //   if (sourceEvent && type === "brush") return;
      //   xScale.domain(transform.rescaleX(xScaleContext).domain());
      //   // focusSVG.selectAll(".category").attr("d", focusArea(xScale, yScale));
      //   focusSVG.select(".axis--x").call(xAxis);
      //   contextSVG
      //     .select(".brush")
      //     .call(brush.move, xScale.range().map(transform.invertX, transform));
      // }

      // const gbrush = svg
      //   .append("g")
      //   .attr("transform", `translate(0, ${height - plotMargin.bottom + 20})`)
      //   .call(brush)
      //   .call(brush.move, defaultSelection);

      // //have a look here...
      // function brushed({ selection }) {
      //   if (selection) {
      //     const [minX, maxX] = selection.map(xScale.invert); //here
      //     // const maxY = contextHeight;//here
      //     // yScale.copy().domain(0, maxY); //and here
      //     d3.selectAll(".category").attr(
      //       "d",
      //       areaFocus(xScale.copy().domain([minX, maxX]), yScale)
      //     );
      //     // d3.select(".xAxis").call(xAxis(xScale.copy().domain([minX, maxX])));
      //   }
      // }

      // function brushended({ selection }) {
      //   if (!selection) {
      //     gbrush.call(brush.move, defaultSelection);
      //   }
      // }

      // svg
      //   .append("rect")
      //   .attr("class", "zoom")
      //   .attr("width", width)
      //   .attr("height", height)
      //   .attr(
      //     "transform",
      //     "translate(" + margin.left + "," + margin.top + ")"
      //   )
      //   .call(zoom);

      // //Create Time Scaled X Axis, then Render
      // const xScale = d3
      //   .scaleTime()
      //   .domain(d3.extent(data, (d) => d.date)) //getting the max and min dates
      //   .range([0, width - plotMargin.left - plotMargin.right]);
      // //have a look here
      // const xAxis = (x) =>
      //   svg
      //     .append("g")
      //     .attr("class", "xAxis")
      //     .attr(
      //       "transform",
      //       `translate(${plotMargin.left},${height - plotMargin.bottom})`
      //     )
      //     .call(
      //       d3
      //         .axisBottom(x)
      //         .ticks(width / 80)
      //         .tickSizeOuter(0)
      //     )
      //     .call((g) => g.select(".domain").remove());

      // xAxis(xScale);

      // //Create Linear Scales Y Axis, then Render
      // const yScale = d3
      //   .scaleLinear()
      //   .domain(
      //     d3.extent(data, (d) =>
      //       d3.sum(Object.values(d).filter((value) => value <= 100000))
      //     )
      //   )
      //   .range([height, plotMargin.bottom]);

      // const yAxis = d3.axisLeft(yScale);
      // svg
      //   .append("g")
      //   .attr(
      //     "transform",
      //     `translate(${plotMargin.left},${-plotMargin.bottom})`
      //   )
      //   .call(yAxis);

      // //Color Palette

      // //Create PlotFocus Area
      // const focus = svg
      //   .append("g")
      //   .attr("class", "focus")
      //   .attr(
      //     "transform",
      //     `translate(${plotMargin.left}, ${-plotMargin.bottom})`
      //   )
      //   .selectAll("path")
      //   .data(series)
      //   .join("path")
      //   .attr("fill", ({ key }) => color(key))
      //   .attr("d", areaFocus(xScale, yScale))
      //   .attr("class", "category")
      //   .append("title")
      //   .text((d) => d.key);

      // const context = svg
      //   .append("g")
      //   .attr("class", "context")
      //   .attr(
      //     "transform",
      //     `translate(${plotMargin.left}, ${height - plotMargin.bottom + 20})`
      //   )
      //   .append("path")
      //   .datum(series[4])
      //   .attr("fill", "steelblue")
      //   .attr(
      //     "d",
      //     areaContext(xScale, yScale.copy().range([contextHeight, 0]))
      //   );

      // //Render Areas

      // //Focus and Context
      // // const brush = d3
      // //   .brushX()
      // //   .extent([
      // //     [plotMargin.left, 0],
      // //     [width - plotMargin.left, contextHeight],
      // //   ])
      // //   .on("brush", brushed)
      // //   .on("end", brushended);

      // const defaultSelection = [
      //   xScale(d3.timeYear.offset(xScale.domain()[1], -1)),
      //   xScale.range()[1],
      // ];

      // const gbrush = svg
      //   .append("g")
      //   .attr("transform", `translate(0, ${height - plotMargin.bottom + 20})`)
      //   .call(brush)
      //   .call(brush.move, defaultSelection);

      // //have a look here...
      // function brushed({ selection }) {
      //   if (selection) {
      //     const [minX, maxX] = selection.map(xScale.invert); //here
      //     // const maxY = contextHeight;//here
      //     // yScale.copy().domain(0, maxY); //and here
      //     d3.selectAll(".category").attr(
      //       "d",
      //       areaFocus(xScale.copy().domain([minX, maxX]), yScale)
      //     );
      //     // d3.select(".xAxis").call(xAxis(xScale.copy().domain([minX, maxX])));
      //   }
      // }

      // function brushended({ selection }) {
      //   if (!selection) {
      //     gbrush.call(brush.move, defaultSelection);
      //   }
      // }

      //Zooming and Paning
      // const zoom = d3.zoom().on("zoom", (e) => {
      //   svg.select(".category").attr("transform", (transform = e.transform));
      // });
      // svg.call(zoom);

      //Tooltip
      // var tooltip = d3
      //   .select("body")
      //   .append("div")
      //   .attr("class", "remove")
      //   .style("position", "absolute")
      //   .style("z-index", "20")
      //   .style("visibility", "hidden")
      //   .style("top", "30px")
      //   .style("left", "55px");

      // });
    </script>
  </body>
</html>
